! function(factory) {
    "object" == typeof module && module.exports ? module.exports = factory : factory(Highcharts)
}(function(HC) {
    "use strict";
    var mathRound = Math.round,
        mathMin = Math.min,
        mathMax = Math.max,
        merge = HC.merge,
        pick = HC.pick,
        each = HC.each,
        inArray = window.HighchartsAdapter && window.HighchartsAdapter.inArray || HC.inArray,
        axisProto = HC.Axis.prototype,
        tickProto = HC.Tick.prototype,
        protoAxisInit = axisProto.init,
        protoAxisRender = axisProto.render,
        protoAxisSetCategories = axisProto.setCategories,
        protoTickGetLabelSize = tickProto.getLabelSize,
        protoTickAddLabel = tickProto.addLabel,
        protoTickDestroy = tickProto.destroy,
        protoTickRender = tickProto.render;

    function deepClone(thing) {
        return JSON.parse(JSON.stringify(thing))
    }

    function Category(obj, parent) {
        return this.userOptions = deepClone(obj), this.name = obj.name || obj, this.parent = parent, this
    }

    function sum(arr) {
        for (var l = arr.length, x = 0; l--;) x += arr[l];
        return x
    }

    function addLeaf(out, cat, parent) {
        for (out.unshift(new Category(cat, parent)); parent;) parent.leaves = parent.leaves ? parent.leaves + 1 : 1, parent = parent.parent
    }

    function addGridPart(path, d, width) {
        d[0] === d[2] && (d[0] = d[2] = mathRound(d[0]) - width % 2 / 2), d[1] === d[3] && (d[1] = d[3] = mathRound(d[1]) + width % 2 / 2), path.push("M", d[0], d[1], "L", d[2], d[3])
    }

    function tickPosition(tick, pos) {
        return tick.getPosition(tick.axis.horiz, pos, tick.axis.tickmarkOffset)
    }

    function walk(arr, key, fn) {
        for (var children, l = arr.length; l--;)(children = arr[l][key]) && walk(children, key, fn), fn(arr[l])
    }
    Category.prototype.toString = function() {
        for (var parts = [], cat = this; cat;) parts.push(cat.name), cat = cat.parent;
        return parts.join(", ")
    }, axisProto.init = function(chart, options) {
        protoAxisInit.call(this, chart, options), "object" == typeof options && options.categories && this.setupGroups(options)
    }, axisProto.setupGroups = function(options) {
        var categories = deepClone(options.categories),
            reverseTree = [],
            stats = {},
            labelOptions = this.options.labels,
            userAttr = labelOptions.groupedOptions,
            css = labelOptions.style;
        ! function buildTree(cats, out, options, parent, depth) {
            var cat, len = cats.length;
            for (depth = depth || 0, options.depth = options.depth ? options.depth : 0; len--;)(cat = cats[len]).categories ? (parent && (cat.parent = parent), buildTree(cat.categories, out, options, cat, depth + 1)) : addLeaf(out, cat, parent);
            options.depth = mathMax(options.depth, depth)
        }(categories, reverseTree, stats), this.categoriesTree = categories, this.categories = reverseTree, this.isGrouped = 0 !== stats.depth, this.labelsDepth = stats.depth, this.labelsSizes = [], this.labelsGridPath = [], this.tickLength = options.tickLength || this.tickLength || null, this.tickWidth = pick(options.tickWidth, this.isXAxis ? 1 : 0), this.directionFactor = [-1, 1, 1, -1][this.side], this.options.lineWidth = pick(options.lineWidth, 1), this.groupFontHeights = [];
        for (var i = 0; i <= stats.depth; i++) {
            var mergedCSS = userAttr && userAttr[i - 1] && userAttr[i - 1].style ? merge(css, userAttr[i - 1].style) : css;
            this.groupFontHeights[i] = Math.round(.3 * this.chart.renderer.fontMetrics(mergedCSS ? mergedCSS.fontSize : 0).b)
        }
    }, axisProto.render = function() {
        if (this.isGrouped && (this.labelsGridPath = []), void 0 === this.originalTickLength && (this.originalTickLength = this.options.tickLength), this.options.tickLength = this.isGrouped ? .001 : this.originalTickLength, protoAxisRender.call(this), !this.isGrouped) return this.labelsGrid && this.labelsGrid.attr({
            visibility: "hidden"
        }), !1;
        var axis = this,
            options = axis.options,
            top = axis.top,
            left = axis.left,
            right = left + axis.width,
            bottom = top + axis.height,
            visible = axis.hasVisibleSeries || axis.hasData,
            depth = axis.labelsDepth,
            grid = axis.labelsGrid,
            horiz = axis.horiz,
            d = axis.labelsGridPath,
            i = !1 === options.drawHorizontalBorders ? depth + 1 : 0,
            offset = axis.opposite ? horiz ? top : right : horiz ? bottom : left,
            tickWidth = axis.tickWidth;
        for (axis.userTickLength && (depth -= 1), grid || (grid = axis.labelsGrid = axis.chart.renderer.path().attr({
                strokeWidth: tickWidth,
                "stroke-width": tickWidth,
                stroke: options.tickColor || ""
            }).add(axis.axisGroup), options.tickColor || grid.addClass("highcharts-tick")); i <= depth;) offset += axis.groupSize(i), addGridPart(d, horiz ? [left, offset, right, offset] : [offset, top, offset, bottom], tickWidth), i++;
        return grid.attr({
            d: d,
            visibility: visible ? "visible" : "hidden"
        }), axis.labelGroup.attr({
            visibility: visible ? "visible" : "hidden"
        }), walk(axis.categoriesTree, "categories", function(group) {
            var tick = group.tick;
            return !!tick && (tick.startAt + tick.leaves - 1 < axis.min || tick.startAt > axis.max ? (tick.label.hide(), tick.destroyed = 0) : tick.label.attr({
                visibility: visible ? "visible" : "hidden"
            }), !0)
        }), !0
    }, axisProto.setCategories = function(newCategories, doRedraw) {
        this.categories && this.cleanGroups(), this.setupGroups({
            categories: newCategories
        }), this.categories = this.userOptions.categories = newCategories, protoAxisSetCategories.call(this, this.categories, doRedraw)
    }, axisProto.cleanGroups = function() {
        var n, ticks = this.ticks;
        for (n in ticks) ticks[n].parent && delete ticks[n].parent;
        walk(this.categoriesTree, "categories", function(group) {
            var tick = group.tick;
            return !!tick && (tick.label.destroy(), each(tick, function(v, i) {
                delete tick[i]
            }), delete group.tick, !0)
        }), this.labelsGrid = null
    }, axisProto.groupSize = function(level, position) {
        var positions = this.labelsSizes,
            direction = this.directionFactor,
            groupedOptions = !!this.options.labels.groupedOptions && this.options.labels.groupedOptions[level - 1],
            userXY = 0;
        return groupedOptions && (userXY = -1 === direction ? groupedOptions.x ? groupedOptions.x : 0 : groupedOptions.y ? groupedOptions.y : 0), void 0 !== position && (positions[level] = mathMax(positions[level] || 0, position + 10 + Math.abs(userXY))), !0 === level ? sum(positions) * direction : positions[level] ? positions[level] * direction : 0
    }, tickProto.addLabel = function() {
        var category, axis = this.axis;
        return protoTickAddLabel.call(this), !(!axis.categories || !(category = axis.categories[this.pos])) && (this.label && this.label.attr("text", this.axis.labelFormatter.call({
            axis: axis,
            chart: axis.chart,
            isFirst: this.isFirst,
            isLast: this.isLast,
            value: category.name,
            pos: this.pos
        })), axis.isGrouped && axis.options.labels.enabled && this.addGroupedLabels(category), !0)
    }, tickProto.addGroupedLabels = function(category) {
        for (var label, tick = this, axis = this.axis, chart = axis.chart, options = axis.options.labels, useHTML = options.useHTML, css = options.style, userAttr = options.groupedOptions, attr = {
                align: "center",
                rotation: options.rotation,
                x: 0,
                y: 0
            }, size = axis.horiz ? "height" : "width", depth = 0; tick;) {
            if (0 < depth && !category.tick) {
                this.value = category.name;
                var name = options.formatter ? options.formatter.call(this, category) : category.name,
                    hasOptions = userAttr && userAttr[depth - 1],
                    mergedAttrs = hasOptions ? merge(attr, userAttr[depth - 1]) : attr,
                    mergedCSS = hasOptions && userAttr[depth - 1].style ? merge(css, userAttr[depth - 1].style) : css;
                delete mergedAttrs.style, label = chart.renderer.text(name, 0, 0, useHTML).attr(mergedAttrs).css(mergedCSS).add(axis.labelGroup), tick.startAt = this.pos, tick.childCount = category.categories.length, tick.leaves = category.leaves, tick.visible = this.childCount, tick.label = label, tick.labelOffsets = {
                    x: mergedAttrs.x,
                    y: mergedAttrs.y
                }, category.tick = tick
            }
            tick && axis.groupSize(depth, tick.label.getBBox()[size]), tick = (category = category.parent) ? tick.parent = category.tick || {} : null, depth++
        }
    }, tickProto.render = function(index, old, opacity) {
        protoTickRender.call(this, index, old, opacity);
        var treeCat = this.axis.categories[this.pos];
        if (this.axis.isGrouped && treeCat && !(this.pos > this.axis.max)) {
            var lvlSize, minPos, maxPos, attrs, bBox, tCat, ret, group = this,
                axis = this.axis,
                tickPos = this.pos,
                isFirst = this.isFirst,
                max = axis.max,
                min = axis.min,
                horiz = axis.horiz,
                grid = axis.labelsGridPath,
                size = axis.groupSize(0),
                tickWidth = axis.tickWidth,
                xy = tickPosition(this, tickPos),
                start = horiz ? xy.y : xy.x,
                baseLine = axis.chart.renderer.fontMetrics(axis.options.labels.style ? axis.options.labels.style.fontSize : 0).b,
                depth = 1,
                reverseCrisp = horiz && xy.x === axis.pos + axis.len || !horiz && xy.y === axis.pos ? -1 : 0;
            for (isFirst && addGridPart(grid, horiz ? [axis.left, xy.y, axis.left, xy.y + axis.groupSize(!0)] : axis.isXAxis ? [xy.x, axis.top, xy.x + axis.groupSize(!0), axis.top] : [xy.x, axis.top + axis.len, xy.x + axis.groupSize(!0), axis.top + axis.len], tickWidth), horiz && axis.left < xy.x ? addGridPart(grid, [xy.x - reverseCrisp, xy.y, xy.x - reverseCrisp, xy.y + size], tickWidth) : !horiz && axis.top <= xy.y && addGridPart(grid, [xy.x, xy.y + reverseCrisp, xy.x + size, xy.y + reverseCrisp], tickWidth), size = start + size; group.parent;) {
                group = group.parent;
                var fix = (tCat = treeCat, ret = void 0, ret = 0, isFirst ? ret = (ret = inArray(tCat.name, tCat.parent.categories)) < 0 ? 0 : ret : ret),
                    userX = group.labelOffsets.x,
                    userY = group.labelOffsets.y;
                minPos = tickPosition(this, mathMax(group.startAt - 1, min - 1)), maxPos = tickPosition(this, mathMin(group.startAt + group.leaves - 1 - fix, max)), bBox = group.label.getBBox(!0), lvlSize = axis.groupSize(depth), reverseCrisp = horiz && maxPos.x === axis.pos + axis.len || !horiz && maxPos.y === axis.pos ? -1 : 0, attrs = horiz ? {
                    x: (minPos.x + maxPos.x) / 2 + userX,
                    y: size + axis.groupFontHeights[depth] + lvlSize / 2 + userY / 2
                } : {
                    x: size + lvlSize / 2 + userX,
                    y: (minPos.y + maxPos.y - bBox.height) / 2 + baseLine + userY
                }, isNaN(attrs.x) || isNaN(attrs.y) || (group.label.attr(attrs), grid && (horiz && axis.left < maxPos.x ? addGridPart(grid, [maxPos.x - reverseCrisp, size, maxPos.x - reverseCrisp, size + lvlSize], tickWidth) : !horiz && axis.top <= maxPos.y && addGridPart(grid, [size, maxPos.y + reverseCrisp, size + lvlSize, maxPos.y + reverseCrisp], tickWidth))), size += lvlSize, depth++
            }
        }
    }, tickProto.destroy = function() {
        for (var group = this.parent; group;) group.destroyed = group.destroyed ? group.destroyed + 1 : 1, group = group.parent;
        protoTickDestroy.call(this)
    }, tickProto.getLabelSize = function() {
        if (!0 !== this.axis.isGrouped) return protoTickGetLabelSize.call(this);
        var size = protoTickGetLabelSize.call(this) + 10;
        return this.axis.labelsSizes[0] < size && (this.axis.labelsSizes[0] = size), sum(this.axis.labelsSizes)
    }
});